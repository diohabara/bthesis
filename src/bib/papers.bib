@inproceedings{alur:2013,
  author    = {Alur, Rajeev and Bodik, Rastislav and Juniwal, Garvit and Martin, Milo M. K. and Raghothaman, Mukund and Seshia, Sanjit A. and Singh, Rishabh and Solar-Lezama, Armando and Torlak, Emina and Udupa, Abhishek},
  booktitle = {2013 Formal Methods in Computer-Aided Design},
  title     = {Syntax-guided synthesis},
  year      = {2013},
  volume    = {},
  number    = {},
  pages     = {1-8},
  doi       = {10.1109/FMCAD.2013.6679385}
}

@article{jha:2010,
  title   = {Oracle-guided component-based program synthesis},
  author  = {Susmit Jha and Sumit Gulwani and Sanjit A. Seshia and Ashish Tiwari},
  journal = {2010 ACM/IEEE 32nd International Conference on Software Engineering},
  year    = {2010},
  volume  = {1},
  pages   = {215-224}
}

@article{bodik:2015,
  author     = {Bodik, Rastislav},
  title      = {Program Synthesis: Opportunities for the next Decade},
  year       = {2015},
  issue_date = {September 2015},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {50},
  number     = {9},
  issn       = {0362-1340},
  url        = {https://doi.org/10.1145/2858949.2789052},
  doi        = {10.1145/2858949.2789052},
  abstract   = { Program synthesis is the contemporary answer to automatic programming. It innovates in two ways: First, it replaces batch automation with interactivity, assisting the programmer in refining the understanding of the programming problem. Second, it produces programs using search in a candidate space rather than by derivation from a specification. Searching for an acceptable program means that we can accommodate incomplete specifications, such as examples. Additionally, search makes synthesis applicable to domains that lack correct-by-construction derivation rules, such as hardware design, education, end-user programming, and systems biology. The future of synthesis rests on four challenges, each presenting an opportunity to develop novel abstractions for "programming with search." Larger scope: today, we synthesize small, flat programs; synthesis of large software will need constructs for modularity and stepwise refinement. New interaction modes: to solicit the specification without simply asking for more examples, we need to impose a structure on the candidate space and explore it in a dialogue. Construction: how to compile a synthesis problem to a search algorithm without building a compiler? Everything is a program: whatever can be phrased as a program can be in principle synthesized. Indeed, we will see synthesis advance from synthesis of plain programs to synthesis of compilers and languages. The latter may include DSLs, type systems, and modeling languages for biology. As such, synthesis could help mechanize the crown jewel of programming languages research --- the design of abstractions --- which has so far been done manually and only by experts. },
  journal    = {SIGPLAN Not.},
  month      = {aug},
  pages      = {1},
  numpages   = {1},
  keywords   = {Program Synthesis}
}

@article{easter:2020,
  author    = {Brandee Easter},
  title     = {Fully Human, Fully Machine: Rhetorics of Digital Disembodiment in Programming},
  journal   = {Rhetoric Review},
  volume    = {39},
  number    = {2},
  pages     = {202-215},
  year      = {2020},
  publisher = {Routledge},
  doi       = {10.1080/07350198.2020.1727096},
  url       = {https://doi.org/10.1080/07350198.2020.1727096},
  eprint    = {https://doi.org/10.1080/07350198.2020.1727096}
}

@inproceedings{guria:2021,
  author    = {Guria, Sankha Narayan and Foster, Jeffrey S. and Van Horn, David},
  title     = {RbSyn: Type- and Effect-Guided Program Synthesis},
  year      = {2021},
  isbn      = {9781450383912},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/3453483.3454048},
  doi       = {10.1145/3453483.3454048},
  abstract  = {In recent years, researchers have explored component-based synthesis, which aims to automatically construct programs that operate by composing calls to existing APIs. However, prior work has not considered efficient synthesis of methods with side effects, e.g., web app methods that update a database. In this paper, we introduce RbSyn, a novel type- and effect-guided synthesis tool for Ruby. An RbSyn synthesis goal is specified as the type for the target method and a series of test cases it must pass. RbSyn works by recursively generating well-typed candidate method bodies whose write effects match the read effects of the test case assertions. After finding a set of candidates that separately satisfy each test, RbSyn synthesizes a solution that branches to execute the correct candidate code under the appropriate conditions. We formalize RbSyn on a core, object-oriented language Î»syn and describe how the key ideas of the model are scaled-up in our implementation for Ruby. We evaluated RbSyn on 19 benchmarks, 12 of which come from popular, open-source Ruby apps. We found that RbSyn synthesizes correct solutions for all benchmarks, with 15 benchmarks synthesizing in under 9 seconds, while the slowest benchmark takes 83 seconds. Using observed reads to guide synthesize is effective: using type-guidance alone times out on 10 of 12 app benchmarks. We also found that using less precise effect annotations leads to worse synthesis performance. In summary, we believe type- and effect-guided synthesis is an important step forward in synthesis of effectful methods from test cases.},
  booktitle = {Proceedings of the 42nd ACM SIGPLAN International Conference on Programming Language Design and Implementation},
  pages     = {344-358},
  numpages  = {15},
  keywords  = {Ruby, program synthesis, type and effect systems},
  location  = {Virtual, Canada},
  series    = {PLDI 2021}
}