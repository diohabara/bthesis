@inproceedings{alur:2013,
  author    = {Alur, Rajeev and Bodik, Rastislav and Juniwal, Garvit and Martin, Milo M. K. and Raghothaman, Mukund and Seshia, Sanjit A. and Singh, Rishabh and Solar-Lezama, Armando and Torlak, Emina and Udupa, Abhishek},
  booktitle = {2013 Formal Methods in Computer-Aided Design},
  title     = {Syntax-guided synthesis},
  year      = {2013},
  volume    = {},
  number    = {},
  pages     = {1-8},
  doi       = {10.1109/FMCAD.2013.6679385}
}

@article{jha:2010,
  title   = {Oracle-guided component-based program synthesis},
  author  = {Susmit Jha and Sumit Gulwani and Sanjit A. Seshia and Ashish Tiwari},
  journal = {2010 ACM/IEEE 32nd International Conference on Software Engineering},
  year    = {2010},
  volume  = {1},
  pages   = {215-224}
}

@article{bodik:2015,
  author     = {Bodik, Rastislav},
  title      = {Program Synthesis: Opportunities for the next Decade},
  year       = {2015},
  issue_date = {September 2015},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {50},
  number     = {9},
  issn       = {0362-1340},
  url        = {https://doi.org/10.1145/2858949.2789052},
  doi        = {10.1145/2858949.2789052},
  abstract   = { Program synthesis is the contemporary answer to automatic programming. It innovates in two ways: First, it replaces batch automation with interactivity, assisting the programmer in refining the understanding of the programming problem. Second, it produces programs using search in a candidate space rather than by derivation from a specification. Searching for an acceptable program means that we can accommodate incomplete specifications, such as examples. Additionally, search makes synthesis applicable to domains that lack correct-by-construction derivation rules, such as hardware design, education, end-user programming, and systems biology. The future of synthesis rests on four challenges, each presenting an opportunity to develop novel abstractions for "programming with search." Larger scope: today, we synthesize small, flat programs; synthesis of large software will need constructs for modularity and stepwise refinement. New interaction modes: to solicit the specification without simply asking for more examples, we need to impose a structure on the candidate space and explore it in a dialogue. Construction: how to compile a synthesis problem to a search algorithm without building a compiler? Everything is a program: whatever can be phrased as a program can be in principle synthesized. Indeed, we will see synthesis advance from synthesis of plain programs to synthesis of compilers and languages. The latter may include DSLs, type systems, and modeling languages for biology. As such, synthesis could help mechanize the crown jewel of programming languages research --- the design of abstractions --- which has so far been done manually and only by experts. },
  journal    = {SIGPLAN Not.},
  month      = {aug},
  pages      = {1},
  numpages   = {1},
  keywords   = {Program Synthesis}
}

@article{easter:2020,
  author    = {Brandee Easter},
  title     = {Fully Human, Fully Machine: Rhetorics of Digital Disembodiment in Programming},
  journal   = {Rhetoric Review},
  volume    = {39},
  number    = {2},
  pages     = {202-215},
  year      = {2020},
  publisher = {Routledge},
  doi       = {10.1080/07350198.2020.1727096},
  url       = {https://doi.org/10.1080/07350198.2020.1727096},
  eprint    = {https://doi.org/10.1080/07350198.2020.1727096}
}

@inproceedings{guria:2021,
  author    = {Guria, Sankha Narayan and Foster, Jeffrey S. and Van Horn, David},
  title     = {RbSyn: Type- and Effect-Guided Program Synthesis},
  year      = {2021},
  isbn      = {9781450383912},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/3453483.3454048},
  doi       = {10.1145/3453483.3454048},
  abstract  = {In recent years, researchers have explored component-based synthesis, which aims to automatically construct programs that operate by composing calls to existing APIs. However, prior work has not considered efficient synthesis of methods with side effects, e.g., web app methods that update a database. In this paper, we introduce RbSyn, a novel type- and effect-guided synthesis tool for Ruby. An RbSyn synthesis goal is specified as the type for the target method and a series of test cases it must pass. RbSyn works by recursively generating well-typed candidate method bodies whose write effects match the read effects of the test case assertions. After finding a set of candidates that separately satisfy each test, RbSyn synthesizes a solution that branches to execute the correct candidate code under the appropriate conditions. We formalize RbSyn on a core, object-oriented language λsyn and describe how the key ideas of the model are scaled-up in our implementation for Ruby. We evaluated RbSyn on 19 benchmarks, 12 of which come from popular, open-source Ruby apps. We found that RbSyn synthesizes correct solutions for all benchmarks, with 15 benchmarks synthesizing in under 9 seconds, while the slowest benchmark takes 83 seconds. Using observed reads to guide synthesize is effective: using type-guidance alone times out on 10 of 12 app benchmarks. We also found that using less precise effect annotations leads to worse synthesis performance. In summary, we believe type- and effect-guided synthesis is an important step forward in synthesis of effectful methods from test cases.},
  booktitle = {Proceedings of the 42nd ACM SIGPLAN International Conference on Programming Language Design and Implementation},
  pages     = {344-358},
  numpages  = {15},
  keywords  = {Ruby, program synthesis, type and effect systems},
  location  = {Virtual, Canada},
  series    = {PLDI 2021}
}

@inproceedings{moura:2008,
  author    = {De Moura, Leonardo and Bj\o{}rner, Nikolaj},
  title     = {Z3: An Efficient SMT Solver},
  year      = {2008},
  isbn      = {3540787992},
  publisher = {Springer-Verlag},
  address   = {Berlin, Heidelberg},
  abstract  = {Satisfiability Modulo Theories (SMT) problem is a decision problem for logical first order formulas with respect to combinations of background theories such as: arithmetic, bit-vectors, arrays, and uninterpreted functions. Z3 is a new and efficient SMT Solver freely available from Microsoft Research. It is used in various software verification and analysis applications.},
  booktitle = {Proceedings of the Theory and Practice of Software, 14th International Conference on Tools and Algorithms for the Construction and Analysis of Systems},
  pages     = {337–340},
  numpages  = {4},
  location  = {Budapest, Hungary},
  series    = {TACAS'08/ETAPS'08}
}

@article{Chen:2021,
  author     = {Mark Chen and
                Jerry Tworek and
                Heewoo Jun and
                Qiming Yuan and
                Henrique Ponde de Oliveira Pinto and
                Jared Kaplan and
                Harrison Edwards and
                Yuri Burda and
                Nicholas Joseph and
                Greg Brockman and
                Alex Ray and
                Raul Puri and
                Gretchen Krueger and
                Michael Petrov and
                Heidy Khlaaf and
                Girish Sastry and
                Pamela Mishkin and
                Brooke Chan and
                Scott Gray and
                Nick Ryder and
                Mikhail Pavlov and
                Alethea Power and
                Lukasz Kaiser and
                Mohammad Bavarian and
                Clemens Winter and
                Philippe Tillet and
                Felipe Petroski Such and
                Dave Cummings and
                Matthias Plappert and
                Fotios Chantzis and
                Elizabeth Barnes and
                Ariel Herbert{-}Voss and
                William Hebgen Guss and
                Alex Nichol and
                Alex Paino and
                Nikolas Tezak and
                Jie Tang and
                Igor Babuschkin and
                Suchir Balaji and
                Shantanu Jain and
                William Saunders and
                Christopher Hesse and
                Andrew N. Carr and
                Jan Leike and
                Joshua Achiam and
                Vedant Misra and
                Evan Morikawa and
                Alec Radford and
                Matthew Knight and
                Miles Brundage and
                Mira Murati and
                Katie Mayer and
                Peter Welinder and
                Bob McGrew and
                Dario Amodei and
                Sam McCandlish and
                Ilya Sutskever and
                Wojciech Zaremba},
  title      = {Evaluating Large Language Models Trained on Code},
  journal    = {CoRR},
  volume     = {abs/2107.03374},
  year       = {2021},
  url        = {https://arxiv.org/abs/2107.03374},
  eprinttype = {arXiv},
  eprint     = {2107.03374},
  timestamp  = {Tue, 20 Jul 2021 15:08:33 +0200},
  biburl     = {https://dblp.org/rec/journals/corr/abs-2107-03374.bib},
  bibsource  = {dblp computer science bibliography, https://dblp.org}
}

@unpublished{Li:2022,
  author = {Yujia Li
            , David Choi
            , Junyoung Chung
            , Nate Kushman
            , Julian Schrittwieser
            , Rémi Leblond
            , Tom Eccles
            , James Keeling
            , Felix Gimeno
            , Agustin Dal Lago
            , Thomas Hubert
            , Peter Choy
            , Cyprien de Masson d’Autume*
            , Igor Babuschkin
            , Xinyun Chen
            , Po-Sen Huang
            , Johannes Welbl
            , Sven Gowal
            , Alexey Cherepanov
            , James Molloy
            , Daniel J. Mankowitz
            , Esme Sutherland Robson
            , Pushmeet Kohli
            , Nando de Freitas
            , Koray Kavukcuoglu and Oriol Vinyals},
  note   = {preprint on webpage at \url{https://storage.googleapis.com/deepmind-media/AlphaCode/competition_level_code_generation_with_alphacode.pdf}},
  title  = {Competition-Level Code Generation with AlphaCode},
  year   = {2022}
}

@article{Schkufza:2016,
  author     = {Schkufza, Eric and Sharma, Rahul and Aiken, Alex},
  title      = {Stochastic Program Optimization},
  year       = {2016},
  issue_date = {February 2016},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {59},
  number     = {2},
  issn       = {0001-0782},
  url        = {https://doi.org/10.1145/2863701},
  doi        = {10.1145/2863701},
  abstract   = {The optimization of short sequences of loop-free, fixed-point assembly code sequences is an important problem in high-performance computing. However, the competing constraints of transformation correctness and performance improvement often force even special purpose compilers to produce sub-optimal code. We show that by encoding these constraints as terms in a cost function, and using a Markov Chain Monte Carlo sampler to rapidly explore the space of all possible code sequences, we are able to generate aggressively optimized versions of a given target code sequence. Beginning from binaries compiled by 11vm --O0, we are able to produce provably correct code sequences that either match or outperform the code produced by qcc --O3, icc --O3, and in some cases expert handwritten assembly.},
  journal    = {Commun. ACM},
  month      = {jan},
  pages      = {114–122},
  numpages   = {9}
}

@article{polozov:2015,
  author     = {Polozov, Oleksandr and Gulwani, Sumit},
  title      = {FlashMeta: A Framework for Inductive Program Synthesis},
  year       = {2015},
  issue_date = {October 2015},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {50},
  number     = {10},
  issn       = {0362-1340},
  url        = {https://doi.org/10.1145/2858965.2814310},
  doi        = {10.1145/2858965.2814310},
  abstract   = { Inductive synthesis, or programming-by-examples (PBE) is gaining prominence with disruptive applications for automating repetitive tasks in end-user programming. However, designing, developing, and maintaining an effective industrial-quality inductive synthesizer is an intellectual and engineering challenge, requiring 1-2 man-years of effort. Our novel observation is that many PBE algorithms are a natural fall-out of one generic meta-algorithm and the domain-specific properties of the operators in the underlying domain-specific language (DSL). The meta-algorithm propagates example-based constraints on an expression to its subexpressions by leveraging associated witness functions, which essentially capture the inverse semantics of the underlying operator. This observation enables a novel program synthesis methodology called data-driven domain-specific deduction (D4), where domain-specific insight, provided by the DSL designer, is separated from the synthesis algorithm. Our FlashMeta framework implements this methodology, allowing synthesizer developers to generate an efficient synthesizer from the mere DSL definition (if properties of the DSL operators have been modeled). In our case studies, we found that 10+ existing industrial-quality mass-market applications based on PBE can be cast as instances of D4. Our evaluation includes reimplementation of some prior works, which in FlashMeta become more efficient, maintainable, and extensible. As a result, FlashMeta-based PBE tools are deployed in several industrial products, including Microsoft PowerShell 3.0 for Windows 10, Azure Operational Management Suite, and Microsoft Cortana digital assistant. },
  journal    = {SIGPLAN Not.},
  month      = {oct},
  pages      = {107–126},
  numpages   = {20},
  keywords   = {frameworks, deductive inference, Inductive program synthesis, programming by examples, search-based synthesis, domain-specific languages}
}

@inproceedings{gulwani:2011,
  author    = {Gulwani, Sumit},
  title     = {Automating String Processing in Spreadsheets using Input-Output Examples},
  booktitle = {PoPL'11, January 26-28, 2011, Austin, Texas, USA},
  year      = {2011},
  month     = {January},
  abstract  = {We describe the design of a string programming/expression language that supports restricted forms of regular expressions, conditionals and loops. The language is expressive enough to represent a wide variety of string manipulation tasks that end-users struggle with. We describe an algorithm based on several novel concepts for synthesizing a desired program in this language from input-output examples. The synthesis algorithm is very efficient taking fraction of a second for various benchmark examples. The synthesis algorithm is interactive and has several desirable features: it can rank multiple solutions and has fast convergence, it can detect noise in the user input, and it supports an active interaction model wherein the user is prompted to provide outputs on inputs that may have multiple computational interpretations.
               
               The algorithm has been implemented as an interactive add-in for Microsoft Excel spreadsheet system. The prototype tool has met the golden test - it has synthesized part of itself, and has been used to solve problems beyond authors' imagination.},
  url       = {https://www.microsoft.com/en-us/research/publication/automating-string-processing-spreadsheets-using-input-output-examples/}
}